using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace PathController.Util
{
    public class MathUtil
    {
		private static ulong m0 = 0x5555555555555555;
		private static ulong m1 = 0x3333333333333333;
		private static ulong m2 = 0x0f0f0f0f0f0f0f0f;
		//private static ulong m3 = 0x00ff00ff00ff00ff;
		//private static ulong m4 = 0x0000ffff0000ffff;

		private static uint[] pop8tab = new uint[]{
			0x00, 0x01, 0x01, 0x02, 0x01, 0x02, 0x02, 0x03, 0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04,
			0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
			0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
			0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
			0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
			0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
			0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
			0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
			0x01, 0x02, 0x02, 0x03, 0x02, 0x03, 0x03, 0x04, 0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05,
			0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
			0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
			0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
			0x02, 0x03, 0x03, 0x04, 0x03, 0x04, 0x04, 0x05, 0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06,
			0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
			0x03, 0x04, 0x04, 0x05, 0x04, 0x05, 0x05, 0x06, 0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07,
			0x04, 0x05, 0x05, 0x06, 0x05, 0x06, 0x06, 0x07, 0x05, 0x06, 0x06, 0x07, 0x06, 0x07, 0x07, 0x08,
		};

			public static int OnesCount32(uint x)
			{
				return Convert.ToInt32(pop8tab[x >> 24] + pop8tab[x >> 16 & 0xff] + pop8tab[x >> 8 & 0xff] + pop8tab[x & 0xff]);
			}

			public int OnesCount64(ulong x) {
			// Implementation: Parallel summing of adjacent bits.
			// See "Hacker's Delight", Chap. 5: Counting Bits.
			// The following pattern shows the general approach:
			//
			//   x = x>>1&(m0&m) + x&(m0&m)
			//   x = x>>2&(m1&m) + x&(m1&m)
			//   x = x>>4&(m2&m) + x&(m2&m)
			//   x = x>>8&(m3&m) + x&(m3&m)
			//   x = x>>16&(m4&m) + x&(m4&m)
			//   x = x>>32&(m5&m) + x&(m5&m)
			//   return int(x)
			//
			// Masking (& operations) can be left away when there's no
			// danger that a field's sum will carry over into the next
			// field: Since the result cannot be > 64, 8 bits is enough
			// and we can ignore the masks for the shifts by 8 and up.
			// Per "Hacker's Delight", the first line can be simplified
			// more, but it saves at best one instruction, so we leave
			// it alone for clarity.
			ulong m = (1 << 64) - 1;
			x = x >> 1 & (m0 & m) + x & (m0 & m);
			x = x >> 2 & (m1 & m) + x & (m1 & m);
			x = ((x >> 4) + x) & (m2 & m);
			x += x >> 8;
			x += x >> 16;
			x += x >> 32;
			x &= (1 << 7 - 1);
			return Convert.ToInt32(x);
		}
	}
}
